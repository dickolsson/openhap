=head1 NAME

FuguLib::Process - Robust process management for forking and execution

=head1 SYNOPSIS

    use FuguLib::Process;

    # Spawn a background process
    my $result = FuguLib::Process->spawn(
        cmd       => ['/usr/bin/some_daemon', 'arg1', 'arg2'],
        daemonize => 1,
        stdout    => '/var/log/daemon.log',
        stderr    => '/var/log/daemon.log',
        on_success => sub($pid) { say "Started PID: $pid" },
        on_error   => sub($err) { warn "Failed: $err" },
    );

    if ($result->{success}) {
        my $pid = $result->{pid};
        # ... later ...
        FuguLib::Process->terminate($pid);
    }

    # Check if process is alive
    if (FuguLib::Process->is_alive($pid)) {
        say "Process $pid is running";
    }

    # Reap zombies
    FuguLib::Process->reap_all();

=head1 DESCRIPTION

FuguLib::Process provides robust process management primitives for forking,
executing commands, tracking PIDs, and handling signals. It solves common
issues like zombie processes, unreliable PID tracking, and error detection
in forked children.

Key features:

=over 4

=item *

Proper zombie reaping with WNOHANG

=item *

Automatic child process liveness verification

=item *

Graceful termination with fallback to SIGKILL

=item *

Daemonization with setsid()

=item *

Flexible I/O redirection

=item *

Callback-based error handling

=back

=head1 METHODS

=head2 spawn

    my $result = FuguLib::Process->spawn(%args);

Fork and execute a command. Returns a hashref with either:

=over 4

=item Success: C<{success => 1, pid => $pid}>

=item Failure: C<{success => 0, error => $message, pid => $pid|undef}>

=back

Arguments:

=over 4

=item C<cmd> (arrayref, required)

Command and arguments to execute. Must be non-empty.

=item C<daemonize> (boolean, default: 0)

If true, child becomes a session leader via setsid().

=item C<stdout> (string, default: /dev/null)

Path for stdout redirection.

=item C<stderr> (string, default: /dev/null)

Path for stderr redirection.

=item C<stdin> (string, default: /dev/null)

Path for stdin redirection.

=item C<check_alive> (seconds, default: 1)

How long to wait before verifying child is alive. Set to 0 to skip check.

=item C<on_success> (coderef, optional)

Called with PID on successful spawn: C<sub($pid) { ... }>

=item C<on_error> (coderef, optional)

Called with error message on failure: C<sub($err) { ... }>

=back

=head2 is_alive

    my $alive = FuguLib::Process->is_alive($pid);

Check if a process is alive using C<kill(0, $pid)>. Returns 1 if alive,
0 if dead or PID is invalid.

=head2 terminate

    my $success = FuguLib::Process->terminate($pid, %args);

Terminate a process gracefully with SIGTERM, falling back to SIGKILL if
necessary. Returns 1 if process was killed or is already dead, 0 on failure.

Arguments:

=over 4

=item C<grace_period> (seconds, default: 5)

Time to wait after SIGTERM before sending SIGKILL.

=item C<on_kill> (coderef, optional)

Called after successful termination.

=back

=head2 reap

    my $reaped = FuguLib::Process->reap($pid);

Attempt to reap a specific zombie process using C<waitpid()> with WNOHANG.
Returns 1 if process was reaped or doesn't exist, 0 if still running.

=head2 reap_all

    my $count = FuguLib::Process->reap_all();

Reap all zombie children (non-blocking). Returns count of processes reaped.
Useful for cleaning up after signal handlers or in long-running processes.

=head2 wait_exit

    my $exited = FuguLib::Process->wait_exit($pid, $timeout);

Wait for a process to exit. Returns 1 if process exited within timeout,
0 otherwise. Default timeout is 30 seconds.

=head1 COMMON PATTERNS

=head2 Long-running Background Process

    my $result = FuguLib::Process->spawn(
        cmd => ['mdnsctl', 'publish', 'MyService', '_hap', 'tcp', 51827, 'txt=value'],
        check_alive => 2,  # Verify alive after 2 seconds
        on_error => sub($err) { log_error("mdnsctl failed: $err") },
    );

    if ($result->{success}) {
        $self->{mdns_pid} = $result->{pid};
    }

=head2 Daemonization

    my $result = FuguLib::Process->spawn(
        cmd => ['/path/to/daemon'],
        daemonize => 1,
        stdout => '/var/log/daemon.log',
        stderr => '/var/log/daemon.log',
    );

=head2 Graceful Shutdown

    # In signal handler or shutdown routine
    FuguLib::Process->terminate($pid, grace_period => 10);

=head2 Zombie Prevention

    # In main loop or signal handler
    FuguLib::Process->reap_all();

=head1 ERROR HANDLING

All methods handle errors gracefully:

=over 4

=item *

Invalid PIDs (undef, non-numeric) are handled safely

=item *

Fork failures are detected and reported

=item *

Child exec failures are detected via liveness check

=item *

Signal send failures are handled (ESRCH, EPERM)

=back

Methods return success/failure indicators rather than dying, allowing
callers to decide how to handle errors.

=head1 OPENBSD CONVENTIONS

This module follows OpenBSD best practices:

=over 4

=item *

Uses C<setsid()> for proper daemonization

=item *

Properly reaps zombies with WNOHANG

=item *

Signals are handled with appropriate escalation (TERM -> KILL)

=item *

File descriptor redirection uses standard paths

=item *

Returns undef for recoverable errors

=back

=head1 SEE ALSO

L<FuguLib::Log>, L<perlfork>, L<perlipc>, L<fork(2)>, L<waitpid(2)>,
L<kill(2)>, L<setsid(2)>

=cut
