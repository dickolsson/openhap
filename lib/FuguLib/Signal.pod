=pod

=head1 NAME

FuguLib::Signal - Robust signal handling for graceful shutdown

=head1 SYNOPSIS

    use FuguLib::Signal;
    
    # Setup graceful exit on interrupt
    my $sig = FuguLib::Signal->new;
    $sig->setup_graceful_exit('INT', 'TERM');
    
    # Add cleanup handler
    $sig->add_cleanup(sub ($signal) {
        print "Cleaning up due to $signal\n";
        # Close files, kill child processes, etc.
    });
    
    # Long-running operation
    while (!FuguLib::Signal::check_interrupted()) {
        # Do work...
        sleep 1;
    }
    
    # Or let signal handler exit automatically
    sleep 9999;  # Will exit cleanly on SIGINT/SIGTERM

=head1 DESCRIPTION

FuguLib::Signal provides robust signal handling for graceful shutdown of
long-running operations. It ensures that processes can be interrupted
cleanly without leaving orphaned resources or corrupt state.

Key features:

=over 4

=item * Automatic signal handler cleanup via object destructor

=item * Cleanup handlers for resource cleanup before exit

=item * Interrupt flag for cooperative cancellation

=item * Standard exit codes (130 for SIGINT)

=item * Restores original signal handlers

=back

=head1 METHODS

=head2 new()

Create a new signal handler manager.

    my $sig = FuguLib::Signal->new;

=head2 setup_graceful_exit(@signals)

Setup handlers that run cleanup and exit on specified signals.

    $sig->setup_graceful_exit('INT', 'TERM', 'HUP');

Exit code will be 130 (standard for SIGINT). All registered cleanup
handlers will be called before exit.

=head2 setup_interrupt_flag(@signals)

Setup handlers that set interrupt flag without exiting immediately.
Allows long-running operations to check flag and exit cleanly.

    $sig->setup_interrupt_flag('INT', 'TERM');
    
    while (!FuguLib::Signal::check_interrupted()) {
        # Do work, checking flag periodically
    }

=head2 add_cleanup($handler)

Add cleanup handler to be called on signal. Handler receives signal
name as argument.

    $sig->add_cleanup(sub ($signal) {
        warn "Interrupted by $signal, cleaning up...\n";
        close $fh;
        kill 'TERM', @child_pids;
    });

Multiple cleanup handlers can be registered and will be called in
order.

=head2 restore()

Restore original signal handlers. Called automatically when object
is destroyed.

    $sig->restore;

=head1 FUNCTIONS

=head2 check_interrupted()

Check if interrupt signal has been received. Returns true if any
registered signal has been caught.

    if (FuguLib::Signal::check_interrupted()) {
        print "Operation cancelled\n";
        exit 130;
    }

=head2 reset_interrupted()

Reset interrupt flag (primarily for testing).

    FuguLib::Signal::reset_interrupted();

=head1 PATTERNS

=head2 Long-Running Operation

    my $sig = FuguLib::Signal->new;
    $sig->setup_interrupt_flag('INT', 'TERM');
    
    for my $item (@items) {
        last if FuguLib::Signal::check_interrupted();
        process($item);
    }

=head2 With Cleanup

    my $sig = FuguLib::Signal->new;
    $sig->add_cleanup(sub ($signal) {
        $dbh->rollback;
        unlink $temp_file;
    });
    $sig->setup_graceful_exit('INT', 'TERM');
    
    # Do work - cleanup runs automatically on signal

=head2 Timeout with Interrupt

    my $sig = FuguLib::Signal->new;
    $sig->setup_interrupt_flag('INT', 'TERM', 'ALRM');
    
    alarm($timeout);
    while (!FuguLib::Signal::check_interrupted()) {
        # Work with timeout
    }
    alarm(0);

=head1 SEE ALSO

L<FuguLib::Process>, L<perlipc>

=cut
